//Q: 什么是类的上下转型？
//A: 在使用继承构建类时会出现这么一个问题，当从一个基类派生出一个衍生类的时候，新的衍生类其实也是属于基类的一种，因为他们有共同属性、方法，即派生类的
  //实例也是可以被看作是基类的实例。如一辆宝马车是小汽车类的实例，同时也是车辆类的实例，即符合A属于B，B属于C，则A属于C的逻辑。
  //如何让编译器知道什么时候我们把派生类的实例当做基类的实例操作？这就需要上转型(Upcasting)操作。反之，如果一个基类的实例刚好拥有所有派生类的属性，
  //我们也可以把基类的实例当作派生类的实例操作，即下转型(Downcasting)操作。
  
//Q: 上下操作看起来就是反过来一样，那么具体实施方法也是类似相反的吗？
//A: 完全不一样。上转型操作看起来很好理解，实际操作起来也确实简单，但是下转型操作就要复杂一些，关键在于被转型的实例必须符合转型成派生类的条件，即其部分
  //构造或全部构造必须完全派生类的构造相同，多一点没关系，少一个属性都不行。否则强行转换会失败，甚至导致程序运行崩溃，即不安全。
  
//Q: 如何实现上下转型？
//A: 先来看简单的上转型。上转型没有什么特别的语法，就是普通的赋值语句，以shape类为例，衍生出circle类，那么Circle类的实例也可以是Shape类的实例，将
  //Circle类的实例circle转换成Shape类的实例方法如下：
  
public class Shape    //声明一个Shape类
{
    
}

public class Circle : Shape   //声明一个Circle类，继承自Shape
{

}

static void Main(string[] args)
{
  var circle = new Circle();    //实例化一个Circle类
  Shape shape = circle;   //将实例circle转换成Shape类只需要声明一个Shap类字段，再将circle赋值进去即可
}

