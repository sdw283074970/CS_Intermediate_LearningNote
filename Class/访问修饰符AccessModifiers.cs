//Q: 什么是访问修饰符？
//A: 访问修饰符(AccessModifiers)又称作访问权限修饰符，顾名思义，访问修饰符界定了其他成员/对象访问被修饰的类、方法、字段的权限。如，被private修饰符修饰
  //的字段不能被该类以外的对象/成员调用、访问。
  
//Q: 都有哪些种类的修饰符？
//A: 在C#中常用的一共有5种修饰符，分别是Public、Private、Protected、Internal和Protected Internal。这里主要讲最常用的Public和Private修饰符，其他的
  //留在接下来的继承(Inheritance)章节中详述。
  
//Q: 为什么要用访问修饰符？
//A: 为了让代码更安全，不让阿猫阿狗的类都能访问每一个字段/方法/类，我们有时候只想公开对外有用的字段/类/方法，其他的只能被内部成员访问。举一个现实的例子，
  //潜艇是国之重器，更多的时候海军只希望敌人看到潜艇发射出去的洲际导弹/鱼雷，而不想让任何人看到潜艇的构造，只让潜艇成员进行操作。离开了内部构造以及艇员
  //的操作，导弹也发射不出去。
  
//Q: 如何使用访问修饰符？
//A: 在申明类/方法/字段的最前面加上访问修饰符即可。如：

public class Example    //public为该类的修饰符
{
  public int i = 0;   //public为该字段的修饰符
  int n = 1;    //没有访问修饰符的情况，即默认为私有(private)
}

static void Mian(string[] args)
{
  var example = new Exampe();
  example.i = 1;    //重新将i的值改为1
  example.n = 2;    //编译器会报错，因为n为私有类型，在Example以外的类中不能访问
}

//为什么要搞成这样？除了让代码安全以外有没有别的用处？答案是有的。访问修饰符更多的用处体现在面向对象编程(OOP)这个过程中的封装(Encapsulation)、
  //继承(Inheritance)和多态性(Polymorphism)中。这里主要讨论封装，另外两个章节会单独列出讲。
  
//Q: 为什么不把一个应用程序的所有的功能写在一个类中？这样就可以避免设置各种权限了。
//A: 在理解OOP之前，首先要明白在实际的软件中，为什么一个我们看得见的功能往往需要很多类/类的实例来协作完成,其核心在耦合性(coupling)。耦合最开始是
  //光电子相关的术语，用来描述模块和模块之间的依赖程度，依赖程度越高则耦合性越高，坏了一个模块/部件就得替换掉大块的其他模块(如集成显卡/CPU/主板)；反之，
  //模块之间的依赖程度越低，则耦合程度越低，即松耦合(loosely coupling)，坏了一个模块，只用替换坏的那部分模块即可。这展现了松耦合的最大优势，高维护性。
  //这也是我们要把一个大功能拆分为很多小功能的核心原因，各个小功能各司其职，只对它自己的那一小部分工作负责，同时只需要少数信息与其他模块交流即可保证
  //程序的稳定运行。在实际编码中，难免在写一些类的时候会偷懒直接访问其他类的成员，这不利于实现松耦合，所以加上了访问修饰符来禁止这种行为。
  
//Q: 什么是封装？
//A: 封装(Encapsulation)即隐藏类的核心功能，不让其他类直到其核心的具体运作方式，最多只知道输入/输出就好。

//Q: 实际操作中封装的核心信息具体是指哪些？如何封装？
//A: 在实际应用中，这些需要被封装的信息即是字段。将这些字段定义为私有(private)访问类型即可。

//Q: 那如果我实在想访问该怎么办？
//A: 私有(private)访问修饰符允许同一个类中的成员经行调用/访问。如果其他类中的方法要访问/调用/获得值，为了安全，我们为这些私有类加上共有调用/赋值的
  //方法即可。即编写两个公共(Public)方法，一个getter用来获取字段的值，一个setter用来将字段赋值，如以下代码：
  
public class Person
{
  private string _name;    //私有封装字段_name，我们不想让其他类随意访问/更改这个值。注意所有私有类型的字段都应使用下划线前缀加camalCase
  
  public void SetName(string name)    //设置一个public的赋值方法，用来在特别的情况更改Name的值，即setter
  {
    if (!String.IsNullOrEmpty(name))    //传入参数必须不为空才能成功设置
      this._name = name;
  }
  
  public string GetName()   //设置一个pubic的方法获得Name的值，即getter
  {
    return _name;
  }
}
  
static Void Main(string[] args)
{
  var person = new Person();
  
  var n = person._name;    //编译器报错，Name为被封装字段
  person._name = "sdw";    //编译器同样报错
  
  var n = person.GetName;   //通过使用getter方法来获取被封装的字段值
  person.SetName("sdw");    //通过使用setter方法来赋值
}
  
  
  
  
  
  


